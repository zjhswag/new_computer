def uniquePaths(m, n):
    """
    :type m: int
    :type n: int
    :rtype: int
    """
    dp = [[0 for _ in range(n)] for _ in range(m)]
    # dp[m][n] = dp[m - 1][n] + dp[m][n-1]
    # print(dp)
    for i in range(0, n):
        dp[0][i] = 1
    for i in range(0, m):
        dp[i][0] = 1
    print(dp)
    # 上面几行代码可以用如下的列表推导式代替，自己不会
    # f = [[1] * n] + [[1] + [0] * (n - 1) for _ in range(m - 1)]
    # 这行代码是用来创建一个m行n列的二维列表，其中第一行都是1，其余行第一列是1，其余元素都是0。
    # 具体来说，这行代码分为两部分：
    # 1. `[[1] * n]`：创建一个只有一行的二维列表，其中每个元素都是1。这是因为`[1] * n`表示一个元素为1的列表，乘以n后就得到了一个包含n个1的列表。
    # 2. `[[1] + [0] * (n - 1) for _ in range(m - 1)]`：创建剩下的m-1行。`[1] + [0] * (n -1)
    # 表示一个长度为n的列表，第一个元素是1，其余元素都是0。然后使用列表推导式，将这个列表复制m-1次，得到一个包含m-1个列表的列表。这样就得到了剩下的m-1行。
    # 最终，使用`+`将第一行和剩下的行连接起来，就得到了一个m行n列的二维列表。
    for i in range(1, m):
        for j in range(1, n):
            dp[i][j] = dp[i - 1][j] + dp[i][j - 1]
    return dp[m - 1][n - 1]


print(uniquePaths(3, 3))

# 2
# 空间优化的未想到
# class Solution:
#     def uniquePaths(self, m: int, n: int) -> int:
#         f = [1] * n               # 起到了初始化第一行和第一列都为 1 的作用
#         for i in range(1, m):
#             for j in range(1, n):
#                 f[j] += f[j - 1]  # f[j] = f[j] + f[j-1] 理解为f[j]为上一行的第j个数据，f[j-1]为当前行的前一个数据，
#                                   # 因为当前位置(i,j)的数据只和当前行的第j-1个数据和前一行的第j个数据有关，
#         return f[n - 1]


# 1 1 1
# 1 2 3
#   3 6
#   4 10
# 因为计算时，当前位置(i,j)的数据只和当前行的第j-1个数据和前一行的第j个数据有关，
# 所以当计算当前行的第j个数据时，可以直接把上一行的第j个数据覆盖，不影响计算结果（即用第i行的数据逐渐覆盖第i-1行，不影响计算结果）。
#

# 上述第一种为自己所想，空间优化未想到 #
